# Практическое занятие 2

## Сортировки

Примеры простых сортировок:
- Сортировка выбором (Selection Sort)
- Сортировка вставками (Insertion Sort)
- Сортировка пузырьком (Bubble Sort)

Общие черты описанных сортировок:
- в качестве входных данных принимается коллекция элементов и критерий сортировки
- основная идея - последовательное формирование и увеличение отсортированной части внутри исходной коллекции
- основными применяемыми операциями являются сравнения и перемещение элементов
- не требуют использования дополнительной информацию (например, о значениях элементов массивов)
- в худшем случае производительность деградирует до квадратичной сложности $O(n^2)$
- имеют констатнтую сложность по памяти $O(1)$

Из вышеперечисленных будут разобраны две сортировки - сортировка выбором (selection sort) и сортировка вставками (insertion sort).

### Сортировка выбором (selection sort)

Особенности алгоритма:
- в самом начале отсортированная часть содержит 0 элементов
- на каждом шаге находим минимальный/максимальный элемент из неотсортированной части коллекции
- меняем найденный минимальный/максимальный элемент с i-м элементом (где элементы в интервале $[0, i-1]$ - это отсортированная часть)
- алгоритм продолжает работу пока размер отсортированной части не станет равным размеру всего массива

Сложность по времени:
- Лучший случай: $O(n^2)$
- Хучший случай: $O(n^2)$
- Общая оценка : $\theta(n^2)$ - (растёт как $n^2$, так как во всех случаях мы делаем порядка $n^2$ операций)

Сложность по памяти:
- Лучший случай: $O(1)$
- Хучший случай: $O(1)$
- Общая оценка : $O(1)$ - используемый объем дополнительной памяти не зависит от входных данных



Реализация на C:

Источник - https://en.wikipedia.org/wiki/Selection_sort

```c 
int i,j;
int aLength; // initialise to a's length

for (i = 0; i < aLength-1; i++)
{
    int jMin = i;
    for (j = i+1; j < aLength; j++)
    {
        if (a[j] < a[jMin])
        {
            // Save index of the minimum element for the swap
            jMin = j;
        }
    }
    // If min element is not next to sorted part - we need to place it there, otherwise can do nothing
    if (jMin != i) 
    {
        // Inside function swap we swap values of i-th and jMin-th elements
        swap(a[i], a[jMin]);
    }
}
```
### Сортировка вставками

Особенности алгоритма:
- в самом начале отсортированная часть содержит 1 элемент (в отличие от сортировки выбором)
- на каждом шаге пытаемся расширить отсортированную часть за счёт следующего за ней элемента, для этого нужно найти его корректную позицию
- последовательно сравниваем новый элемент с предыдущим и меняем их местами если порядок в паре не соответствуют заданному критерию сортировки
- второй способ: просто сдвигаем вправо предыдущий элемент пока не найдем место для  нового, после делаем вставку нового
- алгоритм продолжает работу пока размер отсортированной части не станет равным размеру всего массива

До расширения отсортированной части:

![image](https://github.com/il-bychkov/algorithms/assets/2277222/a518dc3b-accf-4d06-9c88-689af88a3b7c)

После расширения отсортированной части:

![image](https://github.com/il-bychkov/algorithms/assets/2277222/32cea938-8013-450f-ade8-d3cd4846157a)

Источник: https://en.wikipedia.org/wiki/Insertion_sort


Сложность по времени:
- Лучший случай: $O(n)$ - если массив уже отсортирован алгоритм не сделает ни одного обмена, только $n$ сравнений
- Хучший случай: $O(n^2)$
  
Сложность по памяти:
- Лучший случай: $O(1)$
- Хучший случай: $O(1)$
- Общая оценка : $O(1)$ - используемый объем дополнительной памяти не зависит от входных данных



Пример реализации на C:

Источник: https://www.geeksforgeeks.org/c-program-for-insertion-sort/

**Заметка:**

Обратите внимание, в приведенной ниже реализации происходит только один обмен, когда мы нашли нужную позицию.
В остальных случаях предыдущий элемент просто копируется вправо (как в алгоритме вставки в массив).
Эта стратегия соответствует второму способу в описании алгоритма.

```c 
// C program for insertion sort
#include <math.h>
#include <stdio.h>
 
/* Function to sort an array 
   using insertion sort*/
void insertionSort(int arr[], int n)
{
    int i, key, j;
    for (i = 1; i < n; i++) 
    {
        key = arr[i];
        j = i - 1;
 
        /* Move elements of arr[0..i-1], 
           that are greater than key, 
           to one position ahead of 
           their current position */
        while (j >= 0 && arr[j] > key) 
        {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}
 
// A utility function to print 
// an array of size n
void printArray(int arr[], int n)
{
    int i;
    for (i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");
}
 
int main()
{
    int arr[] = {12, 11, 13, 5, 6};
    // Some trick to make "hardcoding" of the whole array more easy - no need to store size, we can compute it
    int n = sizeof(arr) / sizeof(arr[0]);
 
    insertionSort(arr, n);
    printArray(arr, n);
 
    return 0;
}
```

## Специальные сортировки

